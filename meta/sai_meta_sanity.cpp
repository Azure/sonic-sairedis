#include "sai_meta.h"
#include <sstream>

// TODO needs to be moved to SAI

// NOTE: since enum is a key we need size, hence HashForEnum
std::unordered_map<sai_object_type_t,std::unordered_map<sai_attr_id_t, const sai_attr_metadata_t*>, HashForEnum> AttributesMetadata;

// Serialization type name resolve 

std::unordered_map<int32_t, std::string> get_serialization_type_map()
{
    std::unordered_map<int32_t, std::string> map;

#define SER_MAP_SET(x) map[(int32_t)SAI_SERIALIZATION_TYPE_ ## x] = # x

    // TODO must be generated from headers

    SER_MAP_SET(BOOL);
    SER_MAP_SET(CHARDATA);
    SER_MAP_SET(UINT8);
    SER_MAP_SET(INT8);
    SER_MAP_SET(UINT16);
    SER_MAP_SET(INT16);
    SER_MAP_SET(UINT32);
    SER_MAP_SET(INT32);
    SER_MAP_SET(UINT64);
    SER_MAP_SET(INT64);
    SER_MAP_SET(MAC);
    SER_MAP_SET(IP4);
    SER_MAP_SET(IP6);
    SER_MAP_SET(IP_ADDRESS);
    SER_MAP_SET(OBJECT_ID);
    SER_MAP_SET(OBJECT_LIST);
    SER_MAP_SET(UINT8_LIST);
    SER_MAP_SET(INT8_LIST);
    SER_MAP_SET(UINT16_LIST);
    SER_MAP_SET(INT16_LIST);
    SER_MAP_SET(UINT32_LIST);
    SER_MAP_SET(INT32_LIST);
    SER_MAP_SET(UINT32_RANGE);
    SER_MAP_SET(INT32_RANGE);
    SER_MAP_SET(VLAN_LIST);

    SER_MAP_SET(ACL_FIELD_DATA_BOOL);
    SER_MAP_SET(ACL_FIELD_DATA_UINT8);
    SER_MAP_SET(ACL_FIELD_DATA_INT8);
    SER_MAP_SET(ACL_FIELD_DATA_UINT16);
    SER_MAP_SET(ACL_FIELD_DATA_INT16);
    SER_MAP_SET(ACL_FIELD_DATA_INT32);
    SER_MAP_SET(ACL_FIELD_DATA_UINT32);
    SER_MAP_SET(ACL_FIELD_DATA_MAC);
    SER_MAP_SET(ACL_FIELD_DATA_IP4);
    SER_MAP_SET(ACL_FIELD_DATA_IP6);
    SER_MAP_SET(ACL_FIELD_DATA_OBJECT_ID);
    SER_MAP_SET(ACL_FIELD_DATA_OBJECT_LIST);
    SER_MAP_SET(ACL_FIELD_DATA_UINT8_LIST);

    SER_MAP_SET(ACL_ACTION_DATA_UINT8);
    SER_MAP_SET(ACL_ACTION_DATA_INT8);
    SER_MAP_SET(ACL_ACTION_DATA_UINT16);
    SER_MAP_SET(ACL_ACTION_DATA_INT16);
    SER_MAP_SET(ACL_ACTION_DATA_UINT32);
    SER_MAP_SET(ACL_ACTION_DATA_INT32);
    SER_MAP_SET(ACL_ACTION_DATA_MAC);
    SER_MAP_SET(ACL_ACTION_DATA_IPV4);
    SER_MAP_SET(ACL_ACTION_DATA_IPV6);
    SER_MAP_SET(ACL_ACTION_DATA_OBJECT_ID);
    SER_MAP_SET(ACL_ACTION_DATA_OBJECT_LIST);

    SER_MAP_SET(PORT_BREAKOUT);
    SER_MAP_SET(QOS_MAP_LIST);

    return map;
}

const std::unordered_map<int32_t, std::string> g_serialization_type_map = get_serialization_type_map();

const char* c_unknown_serialization_type = "UNKNOWN_SERIALIZATION_TYPE";

const char* get_serialization_type_name(sai_attr_serialization_type_t s)
{
    auto it = g_serialization_type_map.find((int32_t)s);

    if (it != g_serialization_type_map.end())
    {
        return it->second.c_str();
    }

    SWSS_LOG_ERROR("serialization type %d not found in map!", s);

    return c_unknown_serialization_type;
}

// Object type name resolve

std::unordered_map<int32_t, std::string> get_object_type_map()
{
    std::unordered_map<int32_t, std::string> map;

#define OBJ_MAP_SET(x) map[(int32_t)SAI_OBJECT_TYPE_ ## x] = # x

    // TODO must be generated from headers

    OBJ_MAP_SET(NULL);
    OBJ_MAP_SET(PORT);
    OBJ_MAP_SET(LAG);
    OBJ_MAP_SET(VIRTUAL_ROUTER);
    OBJ_MAP_SET(NEXT_HOP);
    OBJ_MAP_SET(NEXT_HOP_GROUP);
    OBJ_MAP_SET(ROUTER_INTERFACE);
    OBJ_MAP_SET(ACL_TABLE);
    OBJ_MAP_SET(ACL_ENTRY);
    OBJ_MAP_SET(ACL_COUNTER);
    OBJ_MAP_SET(ACL_RANGE);
    OBJ_MAP_SET(HOST_INTERFACE);
    OBJ_MAP_SET(MIRROR);
    OBJ_MAP_SET(SAMPLEPACKET);
    OBJ_MAP_SET(STP_INSTANCE);
    OBJ_MAP_SET(TRAP_GROUP);
    OBJ_MAP_SET(ACL_TABLE_GROUP);
    OBJ_MAP_SET(POLICER);
    OBJ_MAP_SET(WRED);
    OBJ_MAP_SET(QOS_MAPS);
    OBJ_MAP_SET(QUEUE);
    OBJ_MAP_SET(SCHEDULER);
    OBJ_MAP_SET(SCHEDULER_GROUP);
    OBJ_MAP_SET(BUFFER_POOL);
    OBJ_MAP_SET(BUFFER_PROFILE);
    OBJ_MAP_SET(PRIORITY_GROUP);
    OBJ_MAP_SET(LAG_MEMBER);
    OBJ_MAP_SET(HASH);
    OBJ_MAP_SET(UDF);
    OBJ_MAP_SET(UDF_MATCH);
    OBJ_MAP_SET(UDF_GROUP);
    OBJ_MAP_SET(FDB);
    OBJ_MAP_SET(SWITCH);
    OBJ_MAP_SET(TRAP);
    OBJ_MAP_SET(TRAP_USER_DEF);
    OBJ_MAP_SET(NEIGHBOR);
    OBJ_MAP_SET(ROUTE);
    OBJ_MAP_SET(VLAN);
    OBJ_MAP_SET(VLAN_MEMBER);
    OBJ_MAP_SET(PACKET);
    OBJ_MAP_SET(TUNNEL_MAP);
    OBJ_MAP_SET(TUNNEL);
    OBJ_MAP_SET(TUNNEL_TABLE_ENTRY);
    OBJ_MAP_SET(MAX);

    return map;
}

const std::unordered_map<int32_t, std::string> g_object_type_map_name = get_object_type_map();

const char* c_unknown_object_type = "UNKNOWN_OBJECT_TYPE";

const char* get_object_type_name(sai_object_type_t o)
{
    auto it = g_object_type_map_name.find((int32_t)o);

    if (it != g_object_type_map_name.end())
    {
        return it->second.c_str();
    }

    SWSS_LOG_ERROR("object type %d not found in map!", o);

    return c_unknown_object_type;
}

// Attribute name resolve

std::unordered_map<int32_t, std::unordered_map<int32_t, std::string>> get_attr_name_map()
{
    std::unordered_map<int32_t, std::unordered_map<int32_t, std::string>> map;

#define ATTR_MAP_SET(x,y) map[(int32_t)SAI_OBJECT_TYPE_ ## x][(int32_t)y] = # y

    // TODO must be generated from headers

    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_STAGE);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_PRIORITY);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_SIZE);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_GROUP_ID);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_STAGE);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_PRIORITY);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_SIZE);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_GROUP_ID);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_END);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_SRC_IPv6);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_DST_IPv6);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_SRC_MAC);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_DST_MAC);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_SRC_IP);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_DST_IP);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_IN_PORTS);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_OUT_PORTS);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_IN_PORT);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_OUT_PORT);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_SRC_PORT);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_OUTER_VLAN_ID);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_OUTER_VLAN_PRI);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_OUTER_VLAN_CFI);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_INNER_VLAN_ID);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_INNER_VLAN_PRI);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_INNER_VLAN_CFI);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_L4_SRC_PORT);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_L4_DST_PORT);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_ETHER_TYPE);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_IP_PROTOCOL);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_DSCP);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_ECN);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_TTL);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_TOS);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_IP_FLAGS);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_TCP_FLAGS);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_IP_TYPE);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_IP_FRAG);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_IPv6_FLOW_LABEL);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_TC);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_ICMP_TYPE);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_ICMP_CODE);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_VLAN_TAGS);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_FDB_DST_USER_META);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_ROUTE_DST_USER_META);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_NEIGHBOR_DST_USER_META);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_PORT_USER_META);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_VLAN_USER_META);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_ACL_USER_META);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_FDB_NPU_META_DST_HIT);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_NEIGHBOR_NPU_META_DST_HIT);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_ROUTE_NPU_META_DST_HIT);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_FIELD_RANGE);
    ATTR_MAP_SET(ACL_TABLE,SAI_ACL_TABLE_ATTR_ACTION_LIST);

    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_TABLE_ID);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_PRIORITY);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_RANGE);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_ACTION_REDIRECT);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_ACTION_REDIRECT_LIST);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_PACKET_ACTION);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_SRC_IPv6);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_DST_IPv6);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_SRC_MAC);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_DST_MAC);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_SRC_IP);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_DST_IP);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_IN_PORTS);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_OUT_PORTS);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_IN_PORT);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_OUT_PORT);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_SRC_PORT);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_OUTER_VLAN_ID);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_OUTER_VLAN_PRI);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_OUTER_VLAN_CFI);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_INNER_VLAN_ID);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_INNER_VLAN_PRI);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_INNER_VLAN_CFI);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_L4_SRC_PORT);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_L4_DST_PORT);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_ETHER_TYPE);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_IP_PROTOCOL);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_DSCP);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_ECN);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_TTL);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_TOS);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_IP_FLAGS);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_TCP_FLAGS);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_IP_TYPE);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_IP_FRAG);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_IPv6_FLOW_LABEL);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_TC);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_ICMP_TYPE);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_ICMP_CODE);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_VLAN_TAGS);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_FDB_DST_USER_META);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_ROUTE_DST_USER_META);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_NEIGHBOR_USER_META);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_PORT_USER_META);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_VLAN_USER_META);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_ACL_USER_META);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_FDB_NPU_META_DST_HIT);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_NEIGHBOR_NPU_META_DST_HIT);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_ROUTE_NPU_META_DST_HIT);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_RANGE);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_ACTION_COUNTER);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_ACTION_MIRROR_INGRESS);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_ACTION_MIRROR_EGRESS);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_ACTION_SET_POLICER);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_ACTION_DECREMENT_TTL);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_ACTION_SET_TC);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_ACTION_SET_TC);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_ACTION_SET_COLOR);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_ACTION_SET_INNER_VLAN_ID);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_ACTION_SET_INNER_VLAN_PRI);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_ACTION_SET_OUTER_VLAN_ID);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_ACTION_SET_OUTER_VLAN_PRI);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_ACTION_SET_SRC_MAC);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_ACTION_SET_DST_MAC);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_ACTION_SET_SRC_IP);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_ACTION_SET_DST_IP);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_ACTION_SET_SRC_IPv6);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_ACTION_SET_DST_IPv6);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_ACTION_SET_DSCP);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_ACTION_SET_ECN);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_ACTION_SET_L4_SRC_PORT);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_ACTION_SET_L4_DST_PORT);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_ACTION_INGRESS_SAMPLEPACKET_ENABLE);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_ACTION_EGRESS_SAMPLEPACKET_ENABLE);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_ACTION_SET_CPU_QUEUE);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_ACTION_SET_ACL_META_DATA);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_ACTION_EGRESS_BLOCK_PORT_LIST);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_ACTION_SET_USER_TRAP_ID);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_FDB_NPU_META_DST_HIT);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_ROUTE_NPU_META_DST_HIT);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_FIELD_NEIGHBOR_NPU_META_DST_HIT);
    ATTR_MAP_SET(ACL_ENTRY,SAI_ACL_ENTRY_ATTR_ACTION_FLOOD);

    ATTR_MAP_SET(ACL_COUNTER,SAI_ACL_COUNTER_ATTR_TABLE_ID);
    ATTR_MAP_SET(ACL_COUNTER,SAI_ACL_COUNTER_ATTR_ENABLE_PACKET_COUNT);
    ATTR_MAP_SET(ACL_COUNTER,SAI_ACL_COUNTER_ATTR_ENABLE_BYTE_COUNT);
    ATTR_MAP_SET(ACL_COUNTER,SAI_ACL_COUNTER_ATTR_PACKETS);
    ATTR_MAP_SET(ACL_COUNTER,SAI_ACL_COUNTER_ATTR_BYTES);
    ATTR_MAP_SET(BUFFER_POOL,SAI_BUFFER_POOL_ATTR_SHARED_SIZE);
    ATTR_MAP_SET(BUFFER_POOL,SAI_BUFFER_POOL_ATTR_TYPE);
    ATTR_MAP_SET(BUFFER_POOL,SAI_BUFFER_POOL_ATTR_SIZE);
    ATTR_MAP_SET(BUFFER_POOL,SAI_BUFFER_POOL_ATTR_TH_MODE);
    ATTR_MAP_SET(BUFFER_PROFILE,SAI_BUFFER_PROFILE_ATTR_POOL_ID);
    ATTR_MAP_SET(BUFFER_PROFILE,SAI_BUFFER_PROFILE_ATTR_BUFFER_SIZE);
    ATTR_MAP_SET(BUFFER_PROFILE,SAI_BUFFER_PROFILE_ATTR_TH_MODE);
    ATTR_MAP_SET(BUFFER_PROFILE,SAI_BUFFER_PROFILE_ATTR_SHARED_DYNAMIC_TH);
    ATTR_MAP_SET(BUFFER_PROFILE,SAI_BUFFER_PROFILE_ATTR_SHARED_STATIC_TH);
    ATTR_MAP_SET(BUFFER_PROFILE,SAI_BUFFER_PROFILE_ATTR_XOFF_TH);
    ATTR_MAP_SET(BUFFER_PROFILE,SAI_BUFFER_PROFILE_ATTR_XON_TH);
    ATTR_MAP_SET(FDB,SAI_FDB_ENTRY_ATTR_TYPE);
    ATTR_MAP_SET(FDB,SAI_FDB_ENTRY_ATTR_PORT_ID);
    ATTR_MAP_SET(FDB,SAI_FDB_ENTRY_ATTR_PACKET_ACTION);
    ATTR_MAP_SET(FDB,SAI_FDB_ENTRY_ATTR_META_DATA);
    ATTR_MAP_SET(HASH,SAI_HASH_ATTR_NATIVE_FIELD_LIST);
    ATTR_MAP_SET(HASH,SAI_HASH_ATTR_UDF_GROUP_LIST);
    ATTR_MAP_SET(HOST_INTERFACE,SAI_HOSTIF_ATTR_TYPE);
    ATTR_MAP_SET(HOST_INTERFACE,SAI_HOSTIF_ATTR_RIF_OR_PORT_ID);
    ATTR_MAP_SET(HOST_INTERFACE,SAI_HOSTIF_ATTR_NAME);
    ATTR_MAP_SET(HOST_INTERFACE,SAI_HOSTIF_ATTR_OPER_STATUS);
    ATTR_MAP_SET(TRAP_GROUP,SAI_HOSTIF_TRAP_GROUP_ATTR_ADMIN_STATE);
    ATTR_MAP_SET(TRAP_GROUP,SAI_HOSTIF_TRAP_GROUP_ATTR_QUEUE);
    ATTR_MAP_SET(TRAP_GROUP,SAI_HOSTIF_TRAP_GROUP_ATTR_POLICER);
    ATTR_MAP_SET(TRAP,SAI_HOSTIF_TRAP_ATTR_PACKET_ACTION);
    ATTR_MAP_SET(TRAP,SAI_HOSTIF_TRAP_ATTR_TRAP_PRIORITY);
    ATTR_MAP_SET(TRAP,SAI_HOSTIF_TRAP_ATTR_TRAP_CHANNEL);
    ATTR_MAP_SET(TRAP,SAI_HOSTIF_TRAP_ATTR_PORT_LIST);
    ATTR_MAP_SET(TRAP,SAI_HOSTIF_TRAP_ATTR_TRAP_GROUP);
    ATTR_MAP_SET(LAG,SAI_LAG_ATTR_PORT_LIST);
    ATTR_MAP_SET(LAG_MEMBER,SAI_LAG_MEMBER_ATTR_LAG_ID);
    ATTR_MAP_SET(LAG_MEMBER,SAI_LAG_MEMBER_ATTR_PORT_ID);
    ATTR_MAP_SET(LAG_MEMBER,SAI_LAG_MEMBER_ATTR_EGRESS_DISABLE);
    ATTR_MAP_SET(LAG_MEMBER,SAI_LAG_MEMBER_ATTR_INGRESS_DISABLE);
    ATTR_MAP_SET(MIRROR,SAI_MIRROR_SESSION_ATTR_TYPE);
    ATTR_MAP_SET(MIRROR,SAI_MIRROR_SESSION_ATTR_MONITOR_PORT);
    //ATTR_MAP_SET(MIRROR,SAI_MIRROR_SESSION_ATTR_TRUNCATE_SIZE);
    ATTR_MAP_SET(MIRROR,SAI_MIRROR_SESSION_ATTR_TC);
    ATTR_MAP_SET(MIRROR,SAI_MIRROR_SESSION_ATTR_VLAN_TPID);
    ATTR_MAP_SET(MIRROR,SAI_MIRROR_SESSION_ATTR_VLAN_ID);
    ATTR_MAP_SET(MIRROR,SAI_MIRROR_SESSION_ATTR_VLAN_PRI);
    //ATTR_MAP_SET(MIRROR,SAI_MIRROR_SESSION_ATTR_VLAN_CFI);
    ATTR_MAP_SET(MIRROR,SAI_MIRROR_SESSION_ATTR_ENCAP_TYPE);
    ATTR_MAP_SET(MIRROR,SAI_MIRROR_SESSION_ATTR_IPHDR_VERSION);
    ATTR_MAP_SET(MIRROR,SAI_MIRROR_SESSION_ATTR_TOS);
    ATTR_MAP_SET(MIRROR,SAI_MIRROR_SESSION_ATTR_TTL);
    ATTR_MAP_SET(MIRROR,SAI_MIRROR_SESSION_ATTR_SRC_IP_ADDRESS);
    ATTR_MAP_SET(MIRROR,SAI_MIRROR_SESSION_ATTR_DST_IP_ADDRESS);
    ATTR_MAP_SET(MIRROR,SAI_MIRROR_SESSION_ATTR_SRC_MAC_ADDRESS);
    ATTR_MAP_SET(MIRROR,SAI_MIRROR_SESSION_ATTR_DST_MAC_ADDRESS);
    ATTR_MAP_SET(MIRROR,SAI_MIRROR_SESSION_ATTR_GRE_PROTOCOL_TYPE);
    ATTR_MAP_SET(NEIGHBOR,SAI_NEIGHBOR_ATTR_DST_MAC_ADDRESS);
    ATTR_MAP_SET(NEIGHBOR,SAI_NEIGHBOR_ATTR_PACKET_ACTION);
    ATTR_MAP_SET(NEIGHBOR,SAI_NEIGHBOR_ATTR_NO_HOST_ROUTE);
    ATTR_MAP_SET(NEIGHBOR,SAI_NEIGHBOR_ATTR_META_DATA);
    ATTR_MAP_SET(NEXT_HOP,SAI_NEXT_HOP_ATTR_TYPE);
    ATTR_MAP_SET(NEXT_HOP,SAI_NEXT_HOP_ATTR_IP);
    ATTR_MAP_SET(NEXT_HOP,SAI_NEXT_HOP_ATTR_ROUTER_INTERFACE_ID);
    ATTR_MAP_SET(NEXT_HOP,SAI_NEXT_HOP_ATTR_TUNNEL_ID);
    ATTR_MAP_SET(NEXT_HOP_GROUP,SAI_NEXT_HOP_GROUP_ATTR_NEXT_HOP_COUNT);
    ATTR_MAP_SET(NEXT_HOP_GROUP,SAI_NEXT_HOP_GROUP_ATTR_TYPE);
    ATTR_MAP_SET(NEXT_HOP_GROUP,SAI_NEXT_HOP_GROUP_ATTR_NEXT_HOP_LIST);
    ATTR_MAP_SET(POLICER,SAI_POLICER_ATTR_METER_TYPE);
    ATTR_MAP_SET(POLICER,SAI_POLICER_ATTR_MODE);
    ATTR_MAP_SET(POLICER,SAI_POLICER_ATTR_COLOR_SOURCE);
    ATTR_MAP_SET(POLICER,SAI_POLICER_ATTR_CBS);
    ATTR_MAP_SET(POLICER,SAI_POLICER_ATTR_CIR);
    ATTR_MAP_SET(POLICER,SAI_POLICER_ATTR_PBS);
    ATTR_MAP_SET(POLICER,SAI_POLICER_ATTR_PIR);
    ATTR_MAP_SET(POLICER,SAI_POLICER_ATTR_GREEN_PACKET_ACTION);
    ATTR_MAP_SET(POLICER,SAI_POLICER_ATTR_YELLOW_PACKET_ACTION);
    ATTR_MAP_SET(POLICER,SAI_POLICER_ATTR_RED_PACKET_ACTION);
    ATTR_MAP_SET(POLICER,SAI_POLICER_ATTR_ENABLE_COUNTER_LIST);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_TYPE);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_OPER_STATUS);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_SUPPORTED_BREAKOUT_MODE);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_CURRENT_BREAKOUT_MODE);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_QOS_NUMBER_OF_QUEUES);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_QOS_QUEUE_LIST);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_QOS_NUMBER_OF_SCHEDULER_GROUPS);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_QOS_SCHEDULER_GROUP_LIST);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_SUPPORTED_SPEED);
/*
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_SUPPORTED_HALF_DUPLEX_SPEED);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_SUPPORTED_AUTO_NEG_MODE);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_SUPPORTED_FLOW_CONTROL);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_SUPPORTED_ASYMMETRIC_PAUSE_MODE);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_SUPPORTED_MEDIA_TYPE);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_REMOTE_SUPPORTED_SPEED);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_REMOTE_SUPPORTED_HALF_DUPLEX_SPEED);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_REMOTE_SUPPORTED_AUTO_NEG_MODE);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_REMOTE_SUPPORTED_FLOW_CONTROL);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_REMOTE_SUPPORTED_ASYMMETRIC_PAUSE_MODE);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_REMOTE_SUPPORTED_MEDIA_TYPE);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_REMOTE_ADVERTISED_SPEED);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_REMOTE_ADVERTISED_HALF_DUPLEX_SPEED);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_REMOTE_ADVERTISED_AUTO_NEG_MODE);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_REMOTE_ADVERTISED_FLOW_CONTROL);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_REMOTE_ADVERTISED_ASYMMETRIC_PAUSE_MODE);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_REMOTE_ADVERTISED_MEDIA_TYPE);
*/
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_NUMBER_OF_PRIORITY_GROUPS);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_PRIORITY_GROUP_LIST);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_HW_LANE_LIST);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_SPEED);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_FULL_DUPLEX_MODE);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_AUTO_NEG_MODE);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_ADMIN_STATE);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_MEDIA_TYPE);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_PORT_VLAN_ID);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_DEFAULT_VLAN_PRIORITY);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_INGRESS_FILTERING);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_DROP_UNTAGGED);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_DROP_TAGGED);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_INTERNAL_LOOPBACK);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_UPDATE_DSCP);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_MTU);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_FLOOD_STORM_CONTROL_POLICER_ID);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_BROADCAST_STORM_CONTROL_POLICER_ID);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_MULTICAST_STORM_CONTROL_POLICER_ID);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_GLOBAL_FLOW_CONTROL);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_MAX_LEARNED_ADDRESSES);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_FDB_LEARNING_LIMIT_VIOLATION);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_INGRESS_MIRROR_SESSION);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_EGRESS_MIRROR_SESSION);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_INGRESS_SAMPLEPACKET_ENABLE);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_EGRESS_SAMPLEPACKET_ENABLE);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_POLICER_ID);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_QOS_DEFAULT_TC);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_QOS_DOT1P_TO_TC_MAP);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_QOS_DOT1P_TO_COLOR_MAP);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_QOS_DSCP_TO_TC_MAP);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_QOS_DSCP_TO_COLOR_MAP);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_QOS_TC_TO_QUEUE_MAP);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_QOS_TC_AND_COLOR_TO_DOT1P_MAP);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_QOS_TC_AND_COLOR_TO_DSCP_MAP);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_QOS_TC_TO_PRIORITY_GROUP_MAP);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_QOS_PFC_PRIORITY_TO_PRIORITY_GROUP_MAP);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_QOS_PFC_PRIORITY_TO_QUEUE_MAP);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_QOS_WRED_PROFILE_ID);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_QOS_SCHEDULER_PROFILE_ID);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_QOS_INGRESS_BUFFER_PROFILE_LIST);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_QOS_EGRESS_BUFFER_PROFILE_LIST);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_PRIORITY_FLOW_CONTROL);
    ATTR_MAP_SET(PORT,SAI_PORT_ATTR_META_DATA);
    //ATTR_MAP_SET(PORT,SAI_PORT_ATTR_EGRESS_BLOCK_PORT_LIST);
    //ATTR_MAP_SET(PORT,SAI_PORT_ATTR_HW_PROFILE_ID);
    ATTR_MAP_SET(QOS_MAPS,SAI_QOS_MAP_ATTR_TYPE);
    ATTR_MAP_SET(QOS_MAPS,SAI_QOS_MAP_ATTR_MAP_TO_VALUE_LIST);
    ATTR_MAP_SET(QUEUE,SAI_QUEUE_ATTR_TYPE);
    ATTR_MAP_SET(QUEUE,SAI_QUEUE_ATTR_WRED_PROFILE_ID);
    ATTR_MAP_SET(QUEUE,SAI_QUEUE_ATTR_BUFFER_PROFILE_ID);
    ATTR_MAP_SET(QUEUE,SAI_QUEUE_ATTR_SCHEDULER_PROFILE_ID);
    ATTR_MAP_SET(ROUTE,SAI_ROUTE_ATTR_PACKET_ACTION);
    ATTR_MAP_SET(ROUTE,SAI_ROUTE_ATTR_TRAP_PRIORITY);
    ATTR_MAP_SET(ROUTE,SAI_ROUTE_ATTR_NEXT_HOP_ID);
    ATTR_MAP_SET(ROUTE,SAI_ROUTE_ATTR_META_DATA);
    ATTR_MAP_SET(VIRTUAL_ROUTER,SAI_VIRTUAL_ROUTER_ATTR_ADMIN_V4_STATE);
    ATTR_MAP_SET(VIRTUAL_ROUTER,SAI_VIRTUAL_ROUTER_ATTR_ADMIN_V6_STATE);
    ATTR_MAP_SET(VIRTUAL_ROUTER,SAI_VIRTUAL_ROUTER_ATTR_SRC_MAC_ADDRESS);
    ATTR_MAP_SET(VIRTUAL_ROUTER,SAI_VIRTUAL_ROUTER_ATTR_VIOLATION_TTL1_ACTION);
    ATTR_MAP_SET(VIRTUAL_ROUTER,SAI_VIRTUAL_ROUTER_ATTR_VIOLATION_IP_OPTIONS);
    ATTR_MAP_SET(ROUTER_INTERFACE,SAI_ROUTER_INTERFACE_ATTR_VIRTUAL_ROUTER_ID);
    ATTR_MAP_SET(ROUTER_INTERFACE,SAI_ROUTER_INTERFACE_ATTR_TYPE);
    ATTR_MAP_SET(ROUTER_INTERFACE,SAI_ROUTER_INTERFACE_ATTR_PORT_ID);
    ATTR_MAP_SET(ROUTER_INTERFACE,SAI_ROUTER_INTERFACE_ATTR_VLAN_ID);
    ATTR_MAP_SET(ROUTER_INTERFACE,SAI_ROUTER_INTERFACE_ATTR_SRC_MAC_ADDRESS);
    ATTR_MAP_SET(ROUTER_INTERFACE,SAI_ROUTER_INTERFACE_ATTR_ADMIN_V4_STATE);
    ATTR_MAP_SET(ROUTER_INTERFACE,SAI_ROUTER_INTERFACE_ATTR_ADMIN_V6_STATE);
    ATTR_MAP_SET(ROUTER_INTERFACE,SAI_ROUTER_INTERFACE_ATTR_MTU);
    ATTR_MAP_SET(ROUTER_INTERFACE,SAI_ROUTER_INTERFACE_ATTR_NEIGHBOR_MISS_PACKET_ACTION);
    ATTR_MAP_SET(SAMPLEPACKET,SAI_SAMPLEPACKET_ATTR_SAMPLE_RATE);
    ATTR_MAP_SET(SAMPLEPACKET,SAI_SAMPLEPACKET_ATTR_TYPE);
    //ATTR_MAP_SET(SAMPLEPACKET,SAI_SAMPLEPACKET_ATTR_MODE);
    ATTR_MAP_SET(SCHEDULER,SAI_SCHEDULER_ATTR_SCHEDULING_ALGORITHM);
    ATTR_MAP_SET(SCHEDULER,SAI_SCHEDULER_ATTR_SCHEDULING_WEIGHT);
    ATTR_MAP_SET(SCHEDULER,SAI_SCHEDULER_ATTR_SHAPER_TYPE);
    ATTR_MAP_SET(SCHEDULER,SAI_SCHEDULER_ATTR_MIN_BANDWIDTH_RATE);
    ATTR_MAP_SET(SCHEDULER,SAI_SCHEDULER_ATTR_MIN_BANDWIDTH_BURST_RATE);
    ATTR_MAP_SET(SCHEDULER,SAI_SCHEDULER_ATTR_MAX_BANDWIDTH_RATE);
    ATTR_MAP_SET(SCHEDULER,SAI_SCHEDULER_ATTR_MAX_BANDWIDTH_BURST_RATE);
    ATTR_MAP_SET(SCHEDULER_GROUP,SAI_SCHEDULER_GROUP_ATTR_CHILD_COUNT);
    ATTR_MAP_SET(SCHEDULER_GROUP,SAI_SCHEDULER_GROUP_ATTR_CHILD_LIST);
    ATTR_MAP_SET(SCHEDULER_GROUP,SAI_SCHEDULER_GROUP_ATTR_PORT_ID);
    ATTR_MAP_SET(SCHEDULER_GROUP,SAI_SCHEDULER_GROUP_ATTR_LEVEL);
    ATTR_MAP_SET(SCHEDULER_GROUP,SAI_SCHEDULER_GROUP_ATTR_MAX_CHILDS);
    ATTR_MAP_SET(SCHEDULER_GROUP,SAI_SCHEDULER_GROUP_ATTR_SCHEDULER_PROFILE_ID);
    ATTR_MAP_SET(STP_INSTANCE,SAI_STP_ATTR_VLAN_LIST);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_PORT_NUMBER);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_PORT_LIST);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_PORT_MAX_MTU);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_CPU_PORT);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_MAX_VIRTUAL_ROUTERS);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_FDB_TABLE_SIZE);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_L3_NEIGHBOR_TABLE_SIZE);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_L3_ROUTE_TABLE_SIZE);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_LAG_MEMBERS);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_NUMBER_OF_LAGS);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_ECMP_MEMBERS);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_NUMBER_OF_ECMP_GROUPS);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_NUMBER_OF_UNICAST_QUEUES);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_NUMBER_OF_MULTICAST_QUEUES);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_NUMBER_OF_QUEUES);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_NUMBER_OF_CPU_QUEUES);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_ON_LINK_ROUTE_SUPPORTED);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_OPER_STATUS);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_MAX_TEMP);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_ACL_TABLE_MINIMUM_PRIORITY);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_ACL_TABLE_MAXIMUM_PRIORITY);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_ACL_ENTRY_MINIMUM_PRIORITY);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_ACL_ENTRY_MAXIMUM_PRIORITY);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_FDB_DST_USER_META_DATA_RANGE);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_ROUTE_DST_USER_META_DATA_RANGE);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_NEIGHBOR_DST_USER_META_DATA_RANGE);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_PORT_USER_META_DATA_RANGE);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_VLAN_USER_META_DATA_RANGE);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_ACL_USER_META_DATA_RANGE);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_ACL_USER_TRAP_ID_RANGE);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_DEFAULT_STP_INST_ID);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_DEFAULT_VIRTUAL_ROUTER_ID);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_QOS_MAX_NUMBER_OF_TRAFFIC_CLASSES);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_QOS_MAX_NUMBER_OF_SCHEDULER_GROUP_HIERARCHY_LEVELS);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_QOS_MAX_NUMBER_OF_SCHEDULER_GROUPS_PER_HIERARCHY_LEVEL);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_QOS_MAX_NUMBER_OF_CHILDS_PER_SCHEDULER_GROUP);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_TOTAL_BUFFER_SIZE);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_INGRESS_BUFFER_POOL_NUM);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_EGRESS_BUFFER_POOL_NUM);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_DEFAULT_TRAP_GROUP);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_ECMP_HASH);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_LAG_HASH);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_RESTART_TYPE);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_MIN_PLANNED_RESTART_INTERVAL);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_NV_STORAGE_SIZE);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_MAX_ACL_ACTION_COUNT);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_SWITCHING_MODE);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_BCAST_CPU_FLOOD_ENABLE);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_MCAST_CPU_FLOOD_ENABLE);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_SRC_MAC_ADDRESS);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_MAX_LEARNED_ADDRESSES);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_FDB_AGING_TIME);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_FDB_UNICAST_MISS_ACTION);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_FDB_BROADCAST_MISS_ACTION);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_FDB_MULTICAST_MISS_ACTION);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_ECMP_DEFAULT_HASH_ALGORITHM);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_ECMP_DEFAULT_HASH_SEED);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_ECMP_DEFAULT_SYMMETRIC_HASH);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_ECMP_HASH_IPV4);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_ECMP_HASH_IPV4_IN_IPV4);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_ECMP_HASH_IPV6);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_LAG_DEFAULT_HASH_ALGORITHM);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_LAG_DEFAULT_HASH_SEED);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_LAG_DEFAULT_SYMMETRIC_HASH);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_LAG_HASH_IPV4);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_LAG_HASH_IPV4_IN_IPV4);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_LAG_HASH_IPV6);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_COUNTER_REFRESH_INTERVAL);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_QOS_DEFAULT_TC);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_QOS_DOT1P_TO_TC_MAP);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_QOS_DOT1P_TO_COLOR_MAP);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_QOS_DSCP_TO_TC_MAP);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_QOS_DSCP_TO_COLOR_MAP);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_QOS_TC_TO_QUEUE_MAP);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_QOS_TC_AND_COLOR_TO_DOT1P_MAP);
    ATTR_MAP_SET(SWITCH,SAI_SWITCH_ATTR_QOS_TC_AND_COLOR_TO_DSCP_MAP);
    ATTR_MAP_SET(TUNNEL,SAI_TUNNEL_ATTR_TYPE);
    ATTR_MAP_SET(TUNNEL,SAI_TUNNEL_ATTR_UNDERLAY_INTERFACE);
    ATTR_MAP_SET(TUNNEL,SAI_TUNNEL_ATTR_OVERLAY_INTERFACE);
    ATTR_MAP_SET(TUNNEL,SAI_TUNNEL_ATTR_ENCAP_SRC_IP);
    ATTR_MAP_SET(TUNNEL,SAI_TUNNEL_ATTR_ENCAP_TTL_MODE);
    ATTR_MAP_SET(TUNNEL,SAI_TUNNEL_ATTR_ENCAP_TTL_VAL);
    ATTR_MAP_SET(TUNNEL,SAI_TUNNEL_ATTR_ENCAP_DSCP_MODE);
    ATTR_MAP_SET(TUNNEL,SAI_TUNNEL_ATTR_ENCAP_DSCP_VAL);
    ATTR_MAP_SET(TUNNEL,SAI_TUNNEL_ATTR_ENCAP_GRE_KEY_VALID);
    ATTR_MAP_SET(TUNNEL,SAI_TUNNEL_ATTR_ENCAP_GRE_KEY);
    ATTR_MAP_SET(TUNNEL,SAI_TUNNEL_ATTR_ENCAP_ECN_MODE);
    ATTR_MAP_SET(TUNNEL,SAI_TUNNEL_ATTR_ENCAP_MAPPERS);
    ATTR_MAP_SET(TUNNEL,SAI_TUNNEL_ATTR_DECAP_ECN_MODE);
    ATTR_MAP_SET(TUNNEL,SAI_TUNNEL_ATTR_DECAP_MAPPERS);
    ATTR_MAP_SET(TUNNEL,SAI_TUNNEL_ATTR_DECAP_TTL_MODE);
    ATTR_MAP_SET(TUNNEL,SAI_TUNNEL_ATTR_DECAP_DSCP_MODE);
    ATTR_MAP_SET(TUNNEL_MAP,SAI_TUNNEL_MAP_ATTR_TYPE);
    ATTR_MAP_SET(TUNNEL_TABLE_ENTRY,SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_VR_ID);
    ATTR_MAP_SET(TUNNEL_TABLE_ENTRY,SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_TYPE);
    ATTR_MAP_SET(TUNNEL_TABLE_ENTRY,SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_DST_IP);
    ATTR_MAP_SET(TUNNEL_TABLE_ENTRY,SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_SRC_IP);
    ATTR_MAP_SET(TUNNEL_TABLE_ENTRY,SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_TUNNEL_TYPE);
    ATTR_MAP_SET(TUNNEL_TABLE_ENTRY,SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_ACTION_TUNNEL_ID);
    ATTR_MAP_SET(UDF,SAI_UDF_ATTR_MATCH_ID);
    ATTR_MAP_SET(UDF,SAI_UDF_ATTR_GROUP_ID);
    ATTR_MAP_SET(UDF,SAI_UDF_ATTR_BASE);
    ATTR_MAP_SET(UDF,SAI_UDF_ATTR_OFFSET);
    ATTR_MAP_SET(UDF,SAI_UDF_ATTR_HASH_MASK);
    ATTR_MAP_SET(UDF_MATCH,SAI_UDF_MATCH_ATTR_L2_TYPE);
    ATTR_MAP_SET(UDF_MATCH,SAI_UDF_MATCH_ATTR_L3_TYPE);
    ATTR_MAP_SET(UDF_MATCH,SAI_UDF_MATCH_ATTR_GRE_TYPE);
    ATTR_MAP_SET(UDF_MATCH,SAI_UDF_MATCH_ATTR_PRIORITY);
    ATTR_MAP_SET(UDF_GROUP,SAI_UDF_GROUP_ATTR_UDF_LIST);
    ATTR_MAP_SET(UDF_GROUP,SAI_UDF_GROUP_ATTR_TYPE);
    ATTR_MAP_SET(UDF_GROUP,SAI_UDF_GROUP_ATTR_LENGTH);
    ATTR_MAP_SET(VLAN,SAI_VLAN_ATTR_MEMBER_LIST);
    ATTR_MAP_SET(VLAN,SAI_VLAN_ATTR_MAX_LEARNED_ADDRESSES);
    ATTR_MAP_SET(VLAN,SAI_VLAN_ATTR_STP_INSTANCE);
    ATTR_MAP_SET(VLAN,SAI_VLAN_ATTR_LEARN_DISABLE);
    ATTR_MAP_SET(VLAN,SAI_VLAN_ATTR_META_DATA);
    ATTR_MAP_SET(VLAN_MEMBER,SAI_VLAN_MEMBER_ATTR_VLAN_ID);
    ATTR_MAP_SET(VLAN_MEMBER,SAI_VLAN_MEMBER_ATTR_PORT_ID);
    ATTR_MAP_SET(VLAN_MEMBER,SAI_VLAN_MEMBER_ATTR_TAGGING_MODE);
    ATTR_MAP_SET(WRED,SAI_WRED_ATTR_ECN_MARK_MODE);
    ATTR_MAP_SET(WRED,SAI_WRED_ATTR_GREEN_ENABLE);
    ATTR_MAP_SET(WRED,SAI_WRED_ATTR_GREEN_MIN_THRESHOLD);
    ATTR_MAP_SET(WRED,SAI_WRED_ATTR_GREEN_MAX_THRESHOLD);
    ATTR_MAP_SET(WRED,SAI_WRED_ATTR_GREEN_DROP_PROBABILITY);
    ATTR_MAP_SET(WRED,SAI_WRED_ATTR_YELLOW_ENABLE);
    ATTR_MAP_SET(WRED,SAI_WRED_ATTR_YELLOW_MIN_THRESHOLD);
    ATTR_MAP_SET(WRED,SAI_WRED_ATTR_YELLOW_MAX_THRESHOLD);
    ATTR_MAP_SET(WRED,SAI_WRED_ATTR_YELLOW_DROP_PROBABILITY);
    ATTR_MAP_SET(WRED,SAI_WRED_ATTR_RED_ENABLE);
    ATTR_MAP_SET(WRED,SAI_WRED_ATTR_RED_MIN_THRESHOLD);
    ATTR_MAP_SET(WRED,SAI_WRED_ATTR_RED_MAX_THRESHOLD);
    ATTR_MAP_SET(WRED,SAI_WRED_ATTR_RED_DROP_PROBABILITY);
    ATTR_MAP_SET(WRED,SAI_WRED_ATTR_WEIGHT);

    return map;
}

const std::unordered_map<int32_t, std::unordered_map<int32_t, std::string>> g_attr_name_map_name = get_attr_name_map();

const char* c_unknown_attr_name = "UNKNOWN_ATTR_NAME";

const char* get_attr_name(sai_object_type_t o, sai_attr_id_t a)
{
    auto it = g_attr_name_map_name.find((int32_t)o);

    if (it == g_attr_name_map_name.end())
    {
        SWSS_LOG_ERROR("object type %d not found in map!", o);

        return c_unknown_attr_name;
    }

    auto ita = it->second.find((int32_t)a);

    if (ita != it->second.end())
    {
        return ita->second.c_str();
    }

    SWSS_LOG_ERROR("object type %d attr id %d not found in map!", o, a);

    return c_unknown_attr_name;
}

#define META_LOG_THROW(md, format, ...) \
{  \
    SWSS_LOG_ERROR("%s, %s (%s) " format, \
            get_object_type_name(md.objecttype),\
            get_attr_name(md.objecttype,md.attrid),\
            get_serialization_type_name(md.serializationtype), \
##__VA_ARGS__);\
    throw;\
}

std::string get_attr_info(const sai_attr_metadata_t& md)
{
    return std::string(get_object_type_name(md.objecttype)) + ":" +
        std::string(get_attr_name(md.objecttype,md.attrid)) + ":" +
        std::string(get_serialization_type_name(md.serializationtype));
}

void metadata_sanity_check(const sai_attr_metadata_t& md)
{
    SWSS_LOG_ENTER();

    SWSS_LOG_INFO("performing metadata sanity check: object type %d, attr id: %d", md.objecttype, md.attrid);

    // check if object type is inside allowed range

    if ((md.objecttype <= SAI_OBJECT_TYPE_NULL) ||
            (md.objecttype >= SAI_OBJECT_TYPE_MAX))
    {
        META_LOG_THROW(md, "invalid object type value");
    }

    auto &attrset = AttributesMetadata[md.objecttype];

    if (attrset.find(md.attrid) != attrset.end())
    {
        META_LOG_THROW(md, "this attribute id is already defined");
    }

    SWSS_LOG_INFO("working on: %s", get_attr_info(md).c_str());

    // TODO since we have valid object type we could validate
    // attributte id range, but that requires extra meta data
    // problem can be when we add custom attributes or attributes
    // have offset ranges like acl flags/action.

    // TODO we could also validate serialization type values

    // check creation flags

    // NOTE: cast is made to prevent warning -Wswitch on combined flags
    // error: case value 'x' not in enumerated type
    switch ((int)md.flags)
    {
        case SAI_ATTR_FLAGS_MANDATORY_ON_CREATE | SAI_ATTR_FLAGS_CREATE_ONLY | SAI_ATTR_FLAGS_KEY:
        case SAI_ATTR_FLAGS_MANDATORY_ON_CREATE | SAI_ATTR_FLAGS_CREATE_ONLY:
        case SAI_ATTR_FLAGS_MANDATORY_ON_CREATE | SAI_ATTR_FLAGS_CREATE_AND_SET:

            if (md.serializationtype == SAI_SERIALIZATION_TYPE_UINT32 &&
                    md.defaultvaluetype == SAI_DEFAULT_VALUE_TYPE_ATTR_RANGE)
            {
                break;
            }

            if (md.defaultvaluetype != SAI_DEFAULT_VALUE_TYPE_NONE)
            {
                META_LOG_THROW(md, "no default value expected, but type provided: %d", md.defaultvaluetype);
            }

            break;

        case SAI_ATTR_FLAGS_CREATE_ONLY:
        case SAI_ATTR_FLAGS_CREATE_AND_SET:

            if (md.defaultvaluetype == SAI_DEFAULT_VALUE_TYPE_NONE)
            {
                META_LOG_THROW(md, "expected no default value, but type provided: %d", md.defaultvaluetype);
            }

            break;

        case SAI_ATTR_FLAGS_READ_ONLY:

            if (md.defaultvaluetype != SAI_DEFAULT_VALUE_TYPE_NONE)
            {
                META_LOG_THROW(md, "no default value expected, but type provided: %d", md.defaultvaluetype);
            }

            if (md.isconditional())
            {
                META_LOG_THROW(md, "read only can't be conditional");
            }

            break;

        default:

            META_LOG_THROW(md, "invalid creation flags: 0x%u", md.flags);
    }

    // check if enum is set only on INT32 serialization type

    if (md.isenum() &&
            (md.serializationtype != SAI_SERIALIZATION_TYPE_INT32) &&
            (md.serializationtype != SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_INT32) &&
            (md.serializationtype != SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_INT32))
    {
        META_LOG_THROW(md, "marked as enum but has invalid serialization type");
    }

    // check if required object type is provided for object expected objects

    switch (md.serializationtype)
    {
        // TODO some acl field/data may require object type
        case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_OBJECT_LIST:
        case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_OBJECT_ID:
        case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_OBJECT_LIST:
        case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_OBJECT_ID:
        case SAI_SERIALIZATION_TYPE_OBJECT_LIST:
        case SAI_SERIALIZATION_TYPE_OBJECT_ID:

            if (md.allowedobjecttypes.size() == 0)
            {
                META_LOG_THROW(md, "object types list is required but it's empty");
            }

            break;

        case SAI_SERIALIZATION_TYPE_BOOL:
        case SAI_SERIALIZATION_TYPE_INT8:
        case SAI_SERIALIZATION_TYPE_INT32:
        case SAI_SERIALIZATION_TYPE_UINT8_LIST:
        case SAI_SERIALIZATION_TYPE_INT32_LIST:
        case SAI_SERIALIZATION_TYPE_UINT8:
        case SAI_SERIALIZATION_TYPE_UINT16:
        case SAI_SERIALIZATION_TYPE_VLAN_LIST:
        case SAI_SERIALIZATION_TYPE_UINT32:
        case SAI_SERIALIZATION_TYPE_UINT64:
        case SAI_SERIALIZATION_TYPE_MAC:
        case SAI_SERIALIZATION_TYPE_IP_ADDRESS:
        case SAI_SERIALIZATION_TYPE_CHARDATA:
        case SAI_SERIALIZATION_TYPE_UINT32_RANGE:
        case SAI_SERIALIZATION_TYPE_UINT32_LIST:
        case SAI_SERIALIZATION_TYPE_QOS_MAP_LIST:

        case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_BOOL:
        case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_UINT8:
        case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_INT8:
        case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_UINT16:
        case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_INT16:
        case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_INT32:
        case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_UINT32:
        case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_MAC:
        case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_IP4:
        case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_IP6:
        case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_UINT8_LIST:

        case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_UINT8:
        case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_INT8:
        case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_UINT16:
        case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_INT16:
        case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_UINT32:
        case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_INT32:
        case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_MAC:
        case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_IPV4:
        case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_IPV6:

            // allowed object types list is not needed here
            break;

        default:
            META_LOG_THROW(md, "serialization type not supported yet");
    }

    // check object types

    if (md.allowedobjecttypes.size() > 0)
    {
        switch (md.serializationtype)
        {
            // ACL also may apply field/data
            case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_OBJECT_LIST:
            case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_OBJECT_ID:
            case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_OBJECT_LIST:
            case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_OBJECT_ID:
            case SAI_SERIALIZATION_TYPE_OBJECT_LIST:
            case SAI_SERIALIZATION_TYPE_OBJECT_ID:
                // ok
                break;

            default:

                META_LOG_THROW(md, "allowed object types should be empty on this serialization type");
        }

        // check if allowed object types are in range
        // they may repeat, but we can also check that

        for (auto& oid: md.allowedobjecttypes)
        {
            if ((oid <= SAI_OBJECT_TYPE_NULL) ||
                    (oid >= SAI_OBJECT_TYPE_MAX))
            {
                META_LOG_THROW(md, "invalid allowed object type: %d", oid);
            }
        }
    }

    bool requiredefault = (!HAS_FLAG_MANDATORY_ON_CREATE(md.flags)) &&
        (HAS_FLAG_CREATE_ONLY(md.flags) || HAS_FLAG_CREATE_AND_SET(md.flags));

    // check for default list not null

    // TODO should default be a pointer? then we could explicitly check if it was set
    if (requiredefault)
    {
        if (md.defaultvaluetype == SAI_DEFAULT_VALUE_TYPE_NONE)
        {
            META_LOG_THROW(md, "expected no default value, but type provided: %d", md.defaultvaluetype);
        }

        // default value is required, should default be a pointer? to force explicit assignment?

        switch (md.serializationtype)
        {

            case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_BOOL:
            case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_UINT8:
            case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_INT8:
            case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_UINT16:
            case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_INT16:
            case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_INT32:
            case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_UINT32:
            case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_MAC:
            case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_IP4:
            case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_IP6:
            case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_OBJECT_ID:
                //case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_UINT8_LIST:

            case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_UINT8:
            case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_INT8:
            case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_UINT16:
            case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_INT16:
            case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_UINT32:
            case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_INT32:
            case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_MAC:
            case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_IPV4:
            case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_IPV6:
            case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_OBJECT_ID:

            case SAI_SERIALIZATION_TYPE_OBJECT_ID:
            case SAI_SERIALIZATION_TYPE_BOOL:
            case SAI_SERIALIZATION_TYPE_INT32:
            case SAI_SERIALIZATION_TYPE_UINT8:
            case SAI_SERIALIZATION_TYPE_UINT16:
            case SAI_SERIALIZATION_TYPE_UINT32:
            case SAI_SERIALIZATION_TYPE_UINT64:
            case SAI_SERIALIZATION_TYPE_MAC:
            case SAI_SERIALIZATION_TYPE_IP_ADDRESS:
                // primitive type, ok
                break;

            case SAI_SERIALIZATION_TYPE_INT32_LIST:
            case SAI_SERIALIZATION_TYPE_OBJECT_LIST:
            case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_OBJECT_LIST:
            case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_OBJECT_LIST:

                if (md.defaultvaluetype == SAI_DEFAULT_VALUE_TYPE_EMPTY_LIST)
                {
                    break;
                }

                META_LOG_THROW(md, "default value list is needed on this serialization type but list is NULL");

                break;

            case SAI_SERIALIZATION_TYPE_UINT8_LIST:

                if (md.defaultvaluetype == SAI_DEFAULT_VALUE_TYPE_EMPTY_LIST)
                {
                    break;
                }

                if (md.defaultvaluetype == SAI_DEFAULT_VALUE_TYPE_CONST &&
                        md.defaultvalue.u8list.list != NULL)
                {
                    break;
                }

                META_LOG_THROW(md, "default value list is needed on this serialization type but list is NULL");

                break;

            default:

                META_LOG_THROW(md, "default value is required but this serialization type is not supported yet");
        }
    }

    if (md.enumtypestr == NULL && !md.enumallowedvalues.empty())
    {
        META_LOG_THROW(md, "enum type string missing, but enum values defined");
    }

    if (md.enumtypestr != NULL && md.enumallowedvalues.empty())
    {
        META_LOG_THROW(md, "enum type string defined, but allowed values are empty");
    }

    if (md.isenum() && md.isenumlist())
    {
        META_LOG_THROW(md, "marked as enum and enumlist, not possible");
    }

    // check enum type string

    if ((md.isenum() || md.isenumlist()) && md.enumtypestr == NULL)
    {
        META_LOG_THROW(md, "is marked enum but missing enum type string");
    }

    if (!(md.isenum() || md.isenumlist()) && md.enumtypestr != NULL)
    {
        META_LOG_THROW(md, "is not marked enum but has defined enum type string");
    }

    // check enum defined values

    if ((md.isenum() || md.isenumlist()) && md.enumallowedvalues.size() == 0)
    {
        META_LOG_THROW(md, "is marked enum but missing enum allowed values");
    }

    if (!(md.isenum() || md.isenumlist()) && md.enumallowedvalues.size() != 0)
    {
        META_LOG_THROW(md, "is not marked enum but has defined enum allowed values");
    }

    if (requiredefault && md.isenum())
    {
        int32_t enumdefault = md.defaultvalue.s32;

        bool found = false;

        for (auto& val: md.enumallowedvalues)
        {
            if (val == enumdefault)
            {
                found = true;
                break;
            }
        }

        if (!found)
        {
            META_LOG_THROW(md, "default enum value %d is not present on enum allowed values (%s)", enumdefault, md.enumtypestr);
        }
    }

    if (requiredefault && md.isenumlist())
    {

        for (uint32_t i = 0 ; i < md.defaultvalue.s32list.count; ++i)
        {
            int32_t item = md.defaultvalue.s32list.list[i];

            bool found = false;

            for (auto& val: md.enumallowedvalues)
            {
                if (val == item)
                {
                    found = true;
                    break;
                }
            }

            if (!found)
            {
                META_LOG_THROW(md, "default enum value %d is not present on enum allowed values (%s)", item, md.enumtypestr);
            }
        }
    }

    //switch (md.conditiontype)
    //{
    //    case SAI_ATTR_CONDITION_TYPE_NONE:
    //    case SAI_ATTR_CONDITION_TYPE_OR:
    //        // ok
    //        break;

    //    default:

    //        META_LOG_THROW(md, "invalid condition type specified: %d", md.conditiontype);
    //}

    switch (md.defaultvaluetype)
    {
        case SAI_DEFAULT_VALUE_TYPE_NONE:
        case SAI_DEFAULT_VALUE_TYPE_CONST:

            // TODO should we check conditions/cretion flags ?
            break;

        case SAI_DEFAULT_VALUE_TYPE_INHERIT:

            // TODO does it make sense to make it inherit
            if (md.objecttype == SAI_OBJECT_TYPE_BUFFER_PROFILE &&
                    md.attrid == SAI_BUFFER_PROFILE_ATTR_TH_MODE)
            {
                // ok
                break;
            }

            META_LOG_THROW(md, "inherit default value type not allowed");

        case SAI_DEFAULT_VALUE_TYPE_ATTR_VALUE:
            // TODO we need to check to which attribute this point's (we may need second run)
            break;

        case SAI_DEFAULT_VALUE_TYPE_ATTR_RANGE:

            // TODO we need to check to which attribute this point's (we may need second run)
            break;

        case SAI_DEFAULT_VALUE_TYPE_EMPTY_LIST:

            switch (md.serializationtype)
            {
                case SAI_SERIALIZATION_TYPE_INT32_LIST:
                case SAI_SERIALIZATION_TYPE_UINT8_LIST:
                case SAI_SERIALIZATION_TYPE_OBJECT_LIST:
                case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_OBJECT_LIST:
                case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_OBJECT_LIST:
                    break;

                default:

                    META_LOG_THROW(md, "default empty list specified, but attribute is not list");
            }

            break;

        case SAI_DEFAULT_VALUE_TYPE_VENDOR_SPECIFIC:

            switch (md.serializationtype)
            {
                case SAI_SERIALIZATION_TYPE_MAC:
                    break;

                default:

                    META_LOG_THROW(md, "vendor specific not allowed on this type");
            }

            break;


        default:

            META_LOG_THROW(md, "invalid default value type specified: %d", md.defaultvaluetype);
    }

    bool conditional = md.isconditional();

    if (!conditional && md.conditions.size() > 0)
    {
        META_LOG_THROW(md, "not conditional but conditions specified");
    }

    if (conditional)
    {
        if (md.conditions.size() == 0)
        {
            META_LOG_THROW(md, "marked as conditional but no conditions specified");
        }

        switch ((int)md.flags)
        {
            case SAI_ATTR_FLAGS_MANDATORY_ON_CREATE | SAI_ATTR_FLAGS_CREATE_AND_SET:

                // if object is mandatory_on_create and create_and_set then it can't
                // be marked as conditional because?? TODO i forgot why
                // some ohter object may depend on it but this attribute can change?
                // this would be caught by below condition on condition

                if (md.objecttype != SAI_OBJECT_TYPE_MIRROR)
                {
                    META_LOG_THROW(md, "marked as conditional on non mirror session, but invalid creation flags: 0x%u", md.flags);
                }

                break;

            case SAI_ATTR_FLAGS_MANDATORY_ON_CREATE | SAI_ATTR_FLAGS_CREATE_ONLY:
            case SAI_ATTR_FLAGS_CREATE_ONLY: // will require default value, on some cases may be dynamic
                // ok
                break;

            default:

                META_LOG_THROW(md, "marked as conditional, but invalid creation flags: 0x%u", md.flags);
        }

        // condition must be the same object type as attribue we check

        auto &hash = AttributesMetadata[md.objecttype];

        for (auto &c: md.conditions)
        {
            if (c.attrid == md.attrid)
            {
                META_LOG_THROW(md, "conditional attr id %d is the same as condition attribute", c.attrid);
            }

            auto it = hash.find(c.attrid);

            if (it == hash.end())
            {
                META_LOG_THROW(md,"conditional attribute id %d was not defined yet in metadata", c.attrid);
            }

            const sai_attr_metadata_t &cmd = *it->second;

            switch (cmd.serializationtype)
            {
                case SAI_SERIALIZATION_TYPE_BOOL:

                    SWSS_LOG_DEBUG("attr id: %d cond.bool: %d", c.attrid, c.condition.booldata);

                    break;

                case SAI_SERIALIZATION_TYPE_INT32:

                    if (!cmd.isenum())
                    {
                        META_LOG_THROW(md, "conditional attribute %d is not enum type", cmd.attrid);
                    }

                    SWSS_LOG_DEBUG("attr id: %d cond.s32: %d ", c.attrid, c.condition.s32);

                    // check if condition enum is in condition attribute range

                    {
                        bool found = false;

                        for (auto& val: cmd.enumallowedvalues)
                        {
                            if (val == c.condition.s32)
                            {
                                found = true;
                                break;
                            }
                        }

                        if (!found)
                        {
                            META_LOG_THROW(md, "condition enum %d not found on condition attribute enum range", c.condition.s32);
                        }
                    }

                    break;

                default:

                    META_LOG_THROW(md, "serialization type %d of conditional attribute is not supported yet", cmd.serializationtype);

            }

            if (cmd.isconditional()) // cmd.conditiontype != SAI_ATTR_CONDITION_TYPE_NONE)
            {
                if (cmd.flags == SAI_ATTR_FLAGS_CREATE_ONLY &&
                        cmd.serializationtype == SAI_SERIALIZATION_TYPE_BOOL)
                {
                    // ok, that means there is default value (it may be depending on switch intenal)
                }
                else
                {
                    META_LOG_THROW(md, "conditional attibute is also conditional, not allowed");
                }
            }

            switch ((int)cmd.flags)
            {
                case SAI_ATTR_FLAGS_MANDATORY_ON_CREATE | SAI_ATTR_FLAGS_CREATE_ONLY | SAI_ATTR_FLAGS_KEY:
                case SAI_ATTR_FLAGS_MANDATORY_ON_CREATE | SAI_ATTR_FLAGS_CREATE_ONLY:
                case SAI_ATTR_FLAGS_CREATE_ONLY:
                    // condition attribute must be create only since
                    // if it could change then other object may be required to pass
                    // on creation time that was not passed
                    break;

                default:

                    META_LOG_THROW(md, "conditional attribute must be create only");
            }
        }
    }

    if (md.isenumlist())
    {
        if (md.serializationtype != SAI_SERIALIZATION_TYPE_INT32_LIST)
        {
            META_LOG_THROW(md, "marked as enum list but wrong serialization type");
        }

        if (conditional)
        {
            META_LOG_THROW(md, "conditional enum list not supported yet");
        }

        // TODO what we need to check more?
    }

    if (md.allownullobjectid)
    {
        switch (md.serializationtype)
        {
            // there may be other types in acl field/data that accept object id
            case SAI_SERIALIZATION_TYPE_OBJECT_ID:
            case SAI_SERIALIZATION_TYPE_OBJECT_LIST:
                // ok
                break;

            default:

                META_LOG_THROW(md, "allow null object is set but serialization type is wrong");
        }

        if (md.allowedobjecttypes.size() == 0)
        {
            META_LOG_THROW(md, "allow null object is set but allowed object types is empty");
        }
    }

    if (HAS_FLAG_KEY(md.flags))
    {
        switch (md.serializationtype)
        {
            case SAI_SERIALIZATION_TYPE_UINT32_LIST:

                if (md.objecttype == SAI_OBJECT_TYPE_PORT && md.attrid == SAI_PORT_ATTR_HW_LANE_LIST)
                {
                    break;
                }

                // list as key is so far supported only on port hw lane list, and it will
                // need to have special handling anyway since lanes may not be reused
                META_LOG_THROW(md, "marked as key, but have invalid serialization type (list)");

            case SAI_SERIALIZATION_TYPE_INT32:
            case SAI_SERIALIZATION_TYPE_UINT32:
            case SAI_SERIALIZATION_TYPE_UINT8:
                // ok
                break;

            default:

                META_LOG_THROW(md, "marked as key, but have invalid serialization type");
        }
    }

    // acl field / action may only be defined on acl entry

    switch (md.serializationtype)
    {
        case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_UINT8:
        case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_INT8:
        case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_UINT16:
        case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_INT16:
        case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_INT32:
        case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_UINT32:
        case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_MAC:
        case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_IP4:
        case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_IP6:
        case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_OBJECT_ID:
        case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_OBJECT_LIST:
        case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_UINT8_LIST:

            if (md.objecttype != SAI_OBJECT_TYPE_ACL_ENTRY ||
                    md.attrid < SAI_ACL_ENTRY_ATTR_FIELD_START ||
                    md.attrid > SAI_ACL_ENTRY_ATTR_FIELD_END)
            {
                // TODO verify if it is correct?
                if (md.objecttype != SAI_OBJECT_TYPE_UDF_MATCH)
                {
                    META_LOG_THROW(md, "acl field may only be set on acl field");
                }
            }

            break;

        case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_UINT8:
        case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_INT8:
        case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_UINT16:
        case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_INT16:
        case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_UINT32:
        case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_INT32:
        case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_MAC:
        case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_IPV4:
        case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_IPV6:
        case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_OBJECT_ID:
        case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_OBJECT_LIST:

            if (md.objecttype != SAI_OBJECT_TYPE_ACL_ENTRY ||
                    md.attrid < SAI_ACL_ENTRY_ATTR_ACTION_START ||
                    md.attrid > SAI_ACL_ENTRY_ATTR_ACTION_END)
            {
                META_LOG_THROW(md, "acl action may only be set on acl action");
            }

            break;

        default:
            break;
    }

    if (md.objecttype == SAI_OBJECT_TYPE_ACL_ENTRY)
    {
        if (md.attrid >= SAI_ACL_ENTRY_ATTR_FIELD_START &&
                md.attrid <= SAI_ACL_ENTRY_ATTR_FIELD_END)
        {
            // serialization type must be correct

            switch (md.serializationtype)
            {
                case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_BOOL:
                case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_UINT8:
                case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_INT8:
                case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_UINT16:
                case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_INT16:
                case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_INT32:
                case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_UINT32:
                case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_MAC:
                case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_IP4:
                case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_IP6:
                case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_OBJECT_ID:
                case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_OBJECT_LIST:
                case SAI_SERIALIZATION_TYPE_ACL_FIELD_DATA_UINT8_LIST:
                    break;

                default:
                    META_LOG_THROW(md, "invalid serialization type for acl field");
            }
        }

        if (md.attrid >= SAI_ACL_ENTRY_ATTR_ACTION_START &&
                md.attrid <= SAI_ACL_ENTRY_ATTR_ACTION_END)
        {
            // serialization type must be correct

            switch (md.serializationtype)
            {
                case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_UINT8:
                case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_INT8:
                case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_UINT16:
                case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_INT16:
                case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_INT32:
                case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_UINT32:
                case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_MAC:
                case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_IPV4:
                case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_IPV6:
                case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_OBJECT_ID:
                case SAI_SERIALIZATION_TYPE_ACL_ACTION_DATA_OBJECT_LIST:
                    break;

                default:
                    META_LOG_THROW(md, "invalid serialization type for acl action");
            }
        }
    }

    if (md.isvlan())
    {
        if (md.serializationtype != SAI_SERIALIZATION_TYPE_UINT16)
        {
            META_LOG_THROW(md, "marked as vlan, but fiels has wrong serialization type");
        }
    }

    // TODO check serialization + creation flags type and check default value type

    // success, add attribute to valid set
    attrset[md.attrid] = &md;

    // we could have metadata automatic created for object types like:
    // bool haveMandatoryAttribytes
    // bool haveMandatoryContitionalAttributes
}

void meta_init()
{
    SWSS_LOG_ENTER();

    static bool initialized = false;

    if (initialized)
    {
        return;
    }

    initialized = true;

    for (int type = SAI_OBJECT_TYPE_NULL + 1; type < SAI_OBJECT_TYPE_MAX; ++type)
    {
        // declare empty attribute list for each object type
        // TODO we could collect those types from metadata directly
        AttributesMetadata[(sai_object_type_t)type] = {};

        SWSS_LOG_INFO("create placeholder for object type %d", type);
    }

#define CHECK(x) \
    for (size_t i = 0; i < sai_ ## x ## _attr_metadata_count; ++i) \
    metadata_sanity_check(sai_ ## x ## _attr_metadata[i]);

    CHECK(acl_counter);
    CHECK(acl_entry);
    CHECK(acl_range);
    CHECK(acl_table);
    CHECK(buffer_pool);
    CHECK(buffer_profile);
    CHECK(fdb);
    CHECK(hash);
    CHECK(hostintf);
    CHECK(hostintf_trap);
    CHECK(hostintf_trap_group);
    CHECK(lag);
    CHECK(lag_member);
    CHECK(mirror);
    CHECK(neighbor);
    CHECK(nexthop);
    CHECK(nexthopgroup);
    CHECK(policer);
    CHECK(port);
    CHECK(qos_maps);
    CHECK(queue);
    CHECK(route);
    CHECK(router);
    CHECK(routerintf);
    CHECK(samplepacket);
    CHECK(scheduler);
    CHECK(scheduler_group);
    CHECK(stp);
    CHECK(switch);
    CHECK(tunnel);
    CHECK(tunnel_map);
    CHECK(tunnel_table_entry);
    CHECK(udf);
    CHECK(udf_group);
    CHECK(udf_match);
    CHECK(vlan);
    CHECK(vlan_member);
    CHECK(wred);
}
